{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///madhatter.deploy.js","webpack:///webpack/bootstrap cede5017d901858e1b36","webpack:///./~/core-js/library/modules/_global.js","webpack:///./~/core-js/library/modules/_core.js","webpack:///./~/core-js/library/modules/_descriptors.js","webpack:///./~/core-js/library/modules/_has.js","webpack:///./~/core-js/library/modules/_object-dp.js","webpack:///./~/core-js/library/modules/_to-iobject.js","webpack:///./~/core-js/library/modules/_hide.js","webpack:///./~/core-js/library/modules/_wks.js","webpack:///./~/core-js/library/modules/_fails.js","webpack:///./~/core-js/library/modules/_an-object.js","webpack:///./~/core-js/library/modules/_export.js","webpack:///./~/core-js/library/modules/_is-object.js","webpack:///./~/core-js/library/modules/_object-keys.js","webpack:///./~/core-js/library/modules/_property-desc.js","webpack:///./~/core-js/library/modules/_uid.js","webpack:///./~/core-js/library/modules/_defined.js","webpack:///./~/core-js/library/modules/_enum-bug-keys.js","webpack:///./~/core-js/library/modules/_iterators.js","webpack:///./~/core-js/library/modules/_library.js","webpack:///./~/core-js/library/modules/_object-pie.js","webpack:///./~/core-js/library/modules/_set-to-string-tag.js","webpack:///./~/core-js/library/modules/_shared-key.js","webpack:///./~/core-js/library/modules/_shared.js","webpack:///./~/core-js/library/modules/_to-integer.js","webpack:///./~/core-js/library/modules/_to-primitive.js","webpack:///./~/core-js/library/modules/_wks-define.js","webpack:///./~/core-js/library/modules/_wks-ext.js","webpack:///./~/core-js/library/modules/_cof.js","webpack:///./~/core-js/library/modules/_dom-create.js","webpack:///./~/core-js/library/modules/_ie8-dom-define.js","webpack:///./~/core-js/library/modules/_iter-define.js","webpack:///./~/core-js/library/modules/_object-create.js","webpack:///./~/core-js/library/modules/_object-gopn-ext.js","webpack:///./~/core-js/library/modules/_object-gopn.js","webpack:///./~/core-js/library/modules/_object-gops.js","webpack:///./~/core-js/library/modules/_object-keys-internal.js","webpack:///./~/core-js/library/modules/_redefine.js","webpack:///./~/core-js/library/modules/es6.symbol.js","webpack:///(webpack)/buildin/global.js","webpack:///./bower_components/esprima/esprima.js","webpack:///asea.js","webpack:///./~/babel-runtime/core-js/object/define-property.js","webpack:///./~/babel-runtime/core-js/object/get-own-property-names.js","webpack:///./~/babel-runtime/core-js/object/get-own-property-symbols.js","webpack:///./~/babel-runtime/core-js/symbol.js","webpack:///./~/babel-runtime/core-js/symbol/iterator.js","webpack:///./~/babel-runtime/helpers/typeof.js","webpack:///./~/core-js/library/fn/object/define-property.js","webpack:///./~/core-js/library/fn/object/get-own-property-names.js","webpack:///./~/core-js/library/fn/object/get-own-property-symbols.js","webpack:///./~/core-js/library/fn/symbol/index.js","webpack:///./~/core-js/library/fn/symbol/iterator.js","webpack:///./~/core-js/library/modules/_a-function.js","webpack:///./~/core-js/library/modules/_add-to-unscopables.js","webpack:///./~/core-js/library/modules/_array-includes.js","webpack:///./~/core-js/library/modules/_ctx.js","webpack:///./~/core-js/library/modules/_enum-keys.js","webpack:///./~/core-js/library/modules/_html.js","webpack:///./~/core-js/library/modules/_iobject.js","webpack:///./~/core-js/library/modules/_is-array.js","webpack:///./~/core-js/library/modules/_iter-create.js","webpack:///./~/core-js/library/modules/_iter-step.js","webpack:///./~/core-js/library/modules/_keyof.js","webpack:///./~/core-js/library/modules/_meta.js","webpack:///./~/core-js/library/modules/_object-dps.js","webpack:///./~/core-js/library/modules/_object-gopd.js","webpack:///./~/core-js/library/modules/_object-gpo.js","webpack:///./~/core-js/library/modules/_object-sap.js","webpack:///./~/core-js/library/modules/_string-at.js","webpack:///./~/core-js/library/modules/_to-index.js","webpack:///./~/core-js/library/modules/_to-length.js","webpack:///./~/core-js/library/modules/_to-object.js","webpack:///./~/core-js/library/modules/es6.array.iterator.js","webpack:///./~/core-js/library/modules/es6.object.define-property.js","webpack:///./~/core-js/library/modules/es6.object.get-own-property-names.js","webpack:///./~/core-js/library/modules/es6.string.iterator.js","webpack:///./~/core-js/library/modules/es7.symbol.async-iterator.js","webpack:///./~/core-js/library/modules/es7.symbol.observable.js","webpack:///./~/core-js/library/modules/web.dom.iterable.js","webpack:///harden.js","webpack:///madhatter.support.js"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","getDefault","getModuleExports","object","property","prototype","hasOwnProperty","p","s","global","window","Math","self","Function","__g","core","version","__e","a","it","key","anObject","IE8_DOM_DEFINE","toPrimitive","dP","f","O","P","Attributes","e","TypeError","IObject","defined","createDesc","store","uid","Symbol","USE_SYMBOL","exec","isObject","ctx","hide","PROTOTYPE","$export","type","source","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","IS_BIND","B","IS_WRAP","W","expProto","target","undefined","C","b","arguments","length","apply","virtual","R","U","$keys","enumBugKeys","keys","bitmap","writable","id","px","random","concat","toString","split","propertyIsEnumerable","def","has","TAG","tag","stat","shared","SHARED","ceil","floor","isNaN","fn","val","valueOf","LIBRARY","wksExt","$Symbol","charAt","slice","document","is","createElement","redefine","Iterators","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","KEYS","VALUES","returnThis","Base","NAME","Constructor","next","DEFAULT","IS_SET","FORCED","methods","IteratorPrototype","getMethod","kind","proto","values","entries","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","dPs","IE_PROTO","Empty","createDict","iframeDocument","iframe","lt","gt","style","display","appendChild","src","contentWindow","open","write","close","create","Properties","result","toIObject","gOPN","windowNames","getOwnPropertyNames","getWindowNames","hiddenKeys","getOwnPropertySymbols","arrayIndexOf","names","push","DESCRIPTORS","META","KEY","$fails","wks","wksDefine","keyOf","enumKeys","isArray","_create","gOPNExt","$GOPD","$DP","gOPD","$JSON","JSON","_stringify","stringify","HIDDEN","TO_PRIMITIVE","isEnum","SymbolRegistry","AllSymbols","OPSymbols","ObjectProto","USE_NATIVE","QObject","setter","findChild","setSymbolDesc","D","protoDesc","wrap","sym","_k","isSymbol","iterator","$defineProperty","$defineProperties","defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","$set","set","symbols","for","keyFor","useSetter","useSimple","replacer","$replacer","args","g","eval","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","assert","condition","message","Error","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","test","String","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isRestrictedWord","isKeyword","strict","addComment","start","end","loc","comment","state","lastCommentStart","extra","range","comments","attachComment","leadingComments","trailingComments","skipSingleLineComment","offset","index","line","lineNumber","column","lineStart","charCodeAt","skipMultiLineComment","throwUnexpectedToken","skipComment","scanHexEscape","prefix","len","code","toLowerCase","scanUnicodeCodePointEscape","cu1","cu2","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Identifier","Keyword","NullLiteral","BooleanLiteral","scanPunctuator","code2","ch2","ch3","ch4","ch1","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","number","NumericLiteral","parseInt","scanBinaryLiteral","scanOctalLiteral","octal","isImplicitOctalLiteral","scanNumericLiteral","parseFloat","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","str","StringLiteral","testRegExp","pattern","flags","tmp","replace","$0","$1","throwError","Messages","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","body","UnterminatedRegExp","literal","scanRegExpFlags","tolerateUnexpectedToken","scanRegExp","lookahead","RegularExpression","regex","collectRegex","pos","token","pop","isIdentifierName","advanceSlash","prevToken","checkToken","FnExprTokens","advance","EOF","collectToken","entry","TokenName","lex","peek","Position","SourceLocation","WrappingSourceLocation","startToken","Node","WrappingNode","peekLineTerminator","found","createError","description","error","messageFormat","msg","Array","whole","idx","tolerateError","errors","unexpectedTokenError","UnexpectedToken","UnexpectedEOS","UnexpectedIdentifier","UnexpectedNumber","UnexpectedString","UnexpectedReserved","StrictReservedWord","expect","expectCommaSeparator","expectKeyword","keyword","match","matchKeyword","matchAssign","op","consumeSemicolon","oldIndex","oldLineNumber","oldLineStart","oldLookahead","isLeftHandSide","expr","Syntax","MemberExpression","parseArrayInitialiser","elements","node","parseAssignmentExpression","finishArrayExpression","parsePropertyFunction","param","first","previousStrict","parseFunctionSourceElements","StrictParamName","finishFunctionExpression","parsePropertyMethodFunction","method","parseParams","params","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseVariableIdentifier","parseObjectInitialiser","properties","map","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","PlaceHolders","ArrowParameterPlaceHolder","parenthesisCount","parseExpression","parsePrimaryExpression","parseFunctionExpression","finishThisExpression","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","callee","parseLeftHandSideExpression","finishNewExpression","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","StrictLHSPostfix","InvalidLHSInAssignment","finishPostfixExpression","parseUnaryExpression","StrictLHSPrefix","finishUnaryExpression","operator","argument","StrictDelete","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","right","left","finishBinaryExpression","parseConditionalExpression","consequent","alternate","finishConditionalExpression","parseConciseBody","reinterpretAsCoverFormalsList","expressions","defaults","defaultCount","options","rest","paramSet","validateParam","AssignmentExpression","StrictParamDupe","stricted","firstRestricted","parseArrowFunctionExpression","finishArrowFunctionExpression","BlockStatement","oldParenthesisCount","list","SequenceExpression","StrictLHSAssignment","finishAssignmentExpression","finishSequenceExpression","parseStatementList","statement","parseSourceElement","parseBlock","block","finishBlockStatement","parseVariableDeclaration","init","StrictVarName","finishVariableDeclarator","parseVariableDeclarationList","parseVariableStatement","declarations","finishVariableDeclaration","parseConstLetDeclaration","parseEmptyStatement","finishEmptyStatement","parseExpressionStatement","finishExpressionStatement","parseIfStatement","parseStatement","finishIfStatement","parseDoWhileStatement","oldInIteration","inIteration","finishDoWhileStatement","parseWhileStatement","finishWhileStatement","parseForVariableDeclaration","parseForStatement","update","InvalidLHSInForIn","finishForStatement","finishForInStatement","parseContinueStatement","label","IllegalContinue","finishContinueStatement","labelSet","UnknownLabel","parseBreakStatement","inSwitch","IllegalBreak","finishBreakStatement","parseReturnStatement","inFunctionBody","IllegalReturn","finishReturnStatement","parseWithStatement","StrictModeWith","finishWithStatement","parseSwitchCase","finishSwitchCase","parseSwitchStatement","discriminant","cases","clause","oldInSwitch","defaultFound","finishSwitchStatement","MultipleDefaultsInSwitch","parseThrowStatement","NewlineAfterThrow","finishThrowStatement","parseCatchClause","StrictCatchVariable","finishCatchClause","parseTryStatement","handlers","finalizer","NoCatchOrFinally","finishTryStatement","parseDebuggerStatement","finishDebuggerStatement","labeledBody","parseFunctionDeclaration","Redeclaration","finishLabeledStatement","sourceElement","directive","oldLabelSet","oldInFunctionBody","sourceElements","expression","Literal","parenthesizedCount","parseParam","StrictFunctionName","finishFunctionDeclaration","parseSourceElements","parseProgram","finishProgram","filterTokenLocation","tolerant","lexError","parse","program","bottomRightStack","ArrayExpression","ArrowFunctionExpression","BinaryExpression","BreakStatement","CallExpression","CatchClause","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","LabeledStatement","LogicalExpression","NewExpression","ObjectExpression","Program","Property","ReturnStatement","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","processComment","lastChild","bottomRight","last","unshift","splice","finish","generator","each","raw","accessor","computed","shorthand","guardedHandlers","types","freeze","harden","asea","client","CLIENT","server","SERVER","UNKNOWN","constructor","process","env","default","_interopRequireDefault","obj","_iterator","_iterator2","_symbol","_symbol2","_typeof","$Object","desc","toLength","toIndex","IS_INCLUDES","$this","el","fromIndex","aFunction","that","getKeys","gOPS","pIE","getSymbols","documentElement","cof","arg","descriptor","done","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","w","fastKey","getWeak","onFreeze","meta","NEED","toObject","fails","exp","toInteger","TO_STRING","max","min","addToUnscopables","step","iterated","_t","_i","Arguments","$at","point","TO_STRING_TAG","collections","Collection","_defineProperty","_defineProperty2","_getOwnPropertySymbols","_getOwnPropertySymbols2","_getOwnPropertyNames","_getOwnPropertyNames2","_typeof2","_typeof3","entity","some","symbol","bind","esprima","FILE_PATH_PATTERN","madhatter","script","lire","check","unusedVariable","unused","filter","onEachUnused","variable","join"],"mappings":"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","file":"madhatter.deploy.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"madhatter\"] = factory();\n\telse\n\t\troot[\"madhatter\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"madhatter\"] = factory();\n\telse\n\t\troot[\"madhatter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 81);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nvar core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(8)(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject       = __webpack_require__(9)\n  , IE8_DOM_DEFINE = __webpack_require__(29)\n  , toPrimitive    = __webpack_require__(24)\n  , dP             = Object.defineProperty;\n\nexports.f = __webpack_require__(2) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(58)\n  , defined = __webpack_require__(15);\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP         = __webpack_require__(4)\n  , createDesc = __webpack_require__(13);\nmodule.exports = __webpack_require__(2) ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store      = __webpack_require__(22)('wks')\n  , uid        = __webpack_require__(14)\n  , Symbol     = __webpack_require__(0).Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(11);\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global    = __webpack_require__(0)\n  , core      = __webpack_require__(1)\n  , ctx       = __webpack_require__(55)\n  , hide      = __webpack_require__(6)\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = __webpack_require__(35)\n  , enumBugKeys = __webpack_require__(16);\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nvar id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\nmodule.exports = true;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar def = __webpack_require__(4).f\n  , has = __webpack_require__(3)\n  , TAG = __webpack_require__(7)('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(22)('keys')\n  , uid    = __webpack_require__(14);\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(0)\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(11);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global         = __webpack_require__(0)\n  , core           = __webpack_require__(1)\n  , LIBRARY        = __webpack_require__(18)\n  , wksExt         = __webpack_require__(26)\n  , defineProperty = __webpack_require__(4).f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports.f = __webpack_require__(7);\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(11)\n  , document = __webpack_require__(0).document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(2) && !__webpack_require__(8)(function(){\n  return Object.defineProperty(__webpack_require__(28)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY        = __webpack_require__(18)\n  , $export        = __webpack_require__(10)\n  , redefine       = __webpack_require__(36)\n  , hide           = __webpack_require__(6)\n  , has            = __webpack_require__(3)\n  , Iterators      = __webpack_require__(17)\n  , $iterCreate    = __webpack_require__(60)\n  , setToStringTag = __webpack_require__(20)\n  , getPrototypeOf = __webpack_require__(66)\n  , ITERATOR       = __webpack_require__(7)('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = __webpack_require__(9)\n  , dPs         = __webpack_require__(64)\n  , enumBugKeys = __webpack_require__(16)\n  , IE_PROTO    = __webpack_require__(21)('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(28)('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(57).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(5)\n  , gOPN      = __webpack_require__(33).f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = __webpack_require__(35)\n  , hiddenKeys = __webpack_require__(16).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has          = __webpack_require__(3)\n  , toIObject    = __webpack_require__(5)\n  , arrayIndexOf = __webpack_require__(54)(false)\n  , IE_PROTO     = __webpack_require__(21)('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(6);\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// ECMAScript 6 symbols shim\nvar global         = __webpack_require__(0)\n  , has            = __webpack_require__(3)\n  , DESCRIPTORS    = __webpack_require__(2)\n  , $export        = __webpack_require__(10)\n  , redefine       = __webpack_require__(36)\n  , META           = __webpack_require__(63).KEY\n  , $fails         = __webpack_require__(8)\n  , shared         = __webpack_require__(22)\n  , setToStringTag = __webpack_require__(20)\n  , uid            = __webpack_require__(14)\n  , wks            = __webpack_require__(7)\n  , wksExt         = __webpack_require__(26)\n  , wksDefine      = __webpack_require__(25)\n  , keyOf          = __webpack_require__(62)\n  , enumKeys       = __webpack_require__(56)\n  , isArray        = __webpack_require__(59)\n  , anObject       = __webpack_require__(9)\n  , toIObject      = __webpack_require__(5)\n  , toPrimitive    = __webpack_require__(24)\n  , createDesc     = __webpack_require__(13)\n  , _create        = __webpack_require__(31)\n  , gOPNExt        = __webpack_require__(32)\n  , $GOPD          = __webpack_require__(65)\n  , $DP            = __webpack_require__(4)\n  , $keys          = __webpack_require__(12)\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  __webpack_require__(33).f = gOPNExt.f = $getOwnPropertyNames;\n  __webpack_require__(19).f  = $propertyIsEnumerable;\n  __webpack_require__(34).f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !__webpack_require__(18)){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(6)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        PropertyKind,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: {\n            type: 'ArrowParameterPlaceHolder'\n        }\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwUnexpectedToken();\n                }\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwUnexpectedToken();\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwUnexpectedToken();\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 0x2E:  // . dot\n        case 0x28:  // ( open bracket\n        case 0x29:  // ) close bracket\n        case 0x3B:  // ; semicolon\n        case 0x2C:  // , comma\n        case 0x7B:  // { open curly brace\n        case 0x7D:  // } close curly brace\n        case 0x5B:  // [\n        case 0x5D:  // ]\n        case 0x3A:  // :\n        case 0x3F:  // ?\n        case 0x7E:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 0x28) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 0x7B) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (U+003D) marks an assignment or comparison operator.\n            if (code2 === 0x3D) {\n                switch (code) {\n                case 0x2B:  // +\n                case 0x2D:  // -\n                case 0x2F:  // /\n                case 0x3C:  // <\n                case 0x3E:  // >\n                case 0x5E:  // ^\n                case 0x7C:  // |\n                case 0x25:  // %\n                case 0x26:  // &\n                case 0x2A:  // *\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n\n                case 0x21: // !\n                case 0x3D: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 0x3D) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n                }\n            }\n        }\n\n        // 4-character punctuator: >>>=\n\n        ch4 = source.substr(index, 4);\n\n        if (ch4 === '>>>=') {\n            index += 4;\n            return {\n                type: Token.Punctuator,\n                value: ch4,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        ch3 = ch4.substr(0, 3);\n\n        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: ch3,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n        ch2 = ch3.substr(0, 2);\n\n        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 1-character punctuators: < > = ! + - * % & | ^ /\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        throwUnexpectedToken();\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            startLineNumber: startLineNumber,\n            startLineStart: startLineStart,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var tmp = pattern,\n            value;\n\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode code point\n            // escape sequence with a single ASCII symbol to avoid throwing on\n            // regular expressions that are only valid in combination with the\n            // `/u` flag.\n            // Note: replacing with the ASCII symbol `x` might cause false\n            // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n            // perfectly valid pattern that is equivalent to `[a-b]`, but it\n            // would be replaced by `[x-b]` which throws an error.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                    if (parseInt($1, 16) <= 0x10FFFF) {\n                        return 'x';\n                    }\n                    throwError(Messages.InvalidRegExp);\n                })\n                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            value = new RegExp(tmp);\n        } catch (e) {\n            throwError(Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError(Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError(Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError(Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        skipComment();\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function Position() {\n        this.line = lineNumber;\n        this.column = index - lineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        if (startToken.type === Token.StringLiteral) {\n            this.start = {\n                line: startToken.startLineNumber,\n                column: startToken.start - startToken.startLineStart\n            };\n        } else {\n            this.start = {\n                line: startToken.lineNumber,\n                column: startToken.start - startToken.lineStart\n            };\n        }\n        this.end = null;\n    }\n\n    function Node() {\n        // Skip comment.\n        index = lookahead.start;\n        if (lookahead.type === Token.StringLiteral) {\n            lineNumber = lookahead.startLineNumber;\n            lineStart = lookahead.startLineStart;\n        } else {\n            lineNumber = lookahead.lineNumber;\n            lineStart = lookahead.lineStart;\n        }\n        if (extra.range) {\n            this.range = [index, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            if (last) {\n                while (last && last.range[0] >= this.range[0]) {\n                    lastChild = last;\n                    last = bottomRight.pop();\n                }\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {\n                    this.leadingComments = lastChild.leadingComments;\n                    lastChild.leadingComments = undefined;\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = index;\n            }\n            if (extra.loc) {\n                this.loc.end = new Position();\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.rest = null;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.rest = null;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.rest = null;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body) {\n            this.type = Syntax.Program;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = guardedHandlers;\n            this.handlers = handlers;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    function createError(line, pos, description) {\n        var error = new Error('Line ' + line + ': ' + description);\n        error.index = pos;\n        error.lineNumber = line;\n        error.column = pos - lineStart + 1;\n        error.description = description;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lineNumber, index, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, index, msg);\n        if (extra.errors) {\n            extra.errors.push(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var msg = Messages.UnexpectedToken;\n\n        if (token) {\n            msg = message ? message :\n                (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                Messages.UnexpectedToken;\n\n            if (token.type === Token.Keyword) {\n                if (isFutureReservedWord(token.value)) {\n                    msg = Messages.UnexpectedReserved;\n                } else if (strict && isStrictModeReservedWord(token.value)) {\n                    msg = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        msg = msg.replace('%0', token ? token.value : 'ILLEGAL');\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(lineNumber, index, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            extra.errors.push(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], node = new Node();\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body, node = new Node();\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            tolerateUnexpectedToken(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, param, [], body);\n    }\n\n    function parsePropertyMethodFunction() {\n        var previousStrict, param, method;\n\n        previousStrict = strict;\n        strict = true;\n        param = parseParams();\n        method = parsePropertyFunction(param.params);\n        strict = previousStrict;\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node();\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param, node = new Node();\n\n        token = lookahead;\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !(match(':') || match('('))) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return node.finishProperty('get', key, value, false, false);\n            }\n            if (token.value === 'set' && !(match(':') || match('('))) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    tolerateUnexpectedToken(token);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return node.finishProperty('set', key, value, false, false);\n            }\n            if (match(':')) {\n                lex();\n                value = parseAssignmentExpression();\n                return node.finishProperty('init', id, value, false, false);\n            }\n            if (match('(')) {\n                value = parsePropertyMethodFunction();\n                return node.finishProperty('init', id, value, true, false);\n            }\n\n            value = id;\n            return node.finishProperty('init', id, value, false, true);\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpectedToken(token);\n        } else {\n            key = parseObjectPropertyKey();\n            if (match(':')) {\n                lex();\n                value = parseAssignmentExpression();\n                return node.finishProperty('init', key, value, false, false);\n            }\n            if (match('(')) {\n                value = parsePropertyMethodFunction();\n                return node.finishProperty('init', key, value, true, false);\n            }\n            throwUnexpectedToken(lex());\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        tolerateError(Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        tolerateError(Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        tolerateError(Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        tolerateError(Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            return PlaceHolders.ArrowParameterPlaceHolder;\n        }\n\n        ++state.parenthesisCount;\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                expr = node.finishThisExpression();\n            } else {\n                throwUnexpectedToken(lex());\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = node.finishLiteral(collectRegex());\n            } else {\n                expr = node.finishLiteral(scanRegExp());\n            }\n            peek();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        for (;;) {\n            if (match('.')) {\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        for (;;) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = parseUnaryExpression();\n        if (left === PlaceHolders.ArrowParameterPlaceHolder) {\n            return left;\n        }\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = parseBinaryExpression();\n        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {\n            return expr;\n        }\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n        }\n\n        return expr;\n    }\n\n    // [ES6] 14.2 Arrow Function\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest, token;\n\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n                validateParam(options, param.left, param.left.name);\n            } else {\n                return null;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            rest: rest,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, body;\n\n        expect('=>');\n        previousStrict = strict;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var oldParenthesisCount, token, expr, right, list, startToken;\n\n        oldParenthesisCount = state.parenthesisCount;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        expr = parseConditionalExpression();\n\n        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            if (state.parenthesisCount === oldParenthesisCount ||\n                    state.parenthesisCount === (oldParenthesisCount + 1)) {\n                if (expr.type === Syntax.Identifier) {\n                    list = reinterpretAsCoverFormalsList([ expr ]);\n                } else if (expr.type === Syntax.AssignmentExpression) {\n                    list = reinterpretAsCoverFormalsList([ expr ]);\n                } else if (expr.type === Syntax.SequenceExpression) {\n                    list = reinterpretAsCoverFormalsList(expr.expressions);\n                } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {\n                    list = reinterpretAsCoverFormalsList([]);\n                }\n                if (list) {\n                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n                }\n            }\n        }\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(expr)) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(parseAssignmentExpression());\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                throwUnexpectedToken(token);\n            }\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration(kind) {\n        var init = null, id, node = new Node();\n\n        id = parseVariableIdentifier();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, node = new Node();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations, kind);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        var node = new Node();\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token, declarations, node = new Node();\n\n        token = lex();\n        declarations = parseVariableDeclarationList();\n\n        return node.finishVariableDeclaration(declarations, token.value);\n    }\n\n    function parseForStatement(node) {\n        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                node.finishForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            // TODO(ikarienator): Should we update the test cases instead?\n            skipComment();\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,\n            node = new Node();\n\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesisCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesisCount;\n\n        return node.finishBlockStatement(sourceElements);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, def;\n\n        token = lookahead;\n        param = parseVariableIdentifier();\n        validateParam(options, token, token.value);\n        if (match('=')) {\n            lex();\n            def = parseAssignmentExpression();\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (index < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();\n\n        expectKeyword('function');\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node();\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionExpression(id, params, defaults, body);\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            /* istanbul ignore if */\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        skipComment();\n        peek();\n        node = new Node();\n        strict = false;\n\n        body = parseSourceElements();\n        return node.finishProgram(body);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            parenthesisCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.0.0';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n   /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n/*;\n              \t@module-license:\n              \t\tThe MIT License (MIT)\n              \t\t@mit-license\n              \n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n              \t\t@email: richeve.bebedor@gmail.com\n              \n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\n              \t\tin the Software without restriction, including without limitation the rights\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n              \t\tcopies of the Software, and to permit persons to whom the Software is\n              \t\tfurnished to do so, subject to the following conditions:\n              \n              \t\tThe above copyright notice and this permission notice shall be included in all\n              \t\tcopies or substantial portions of the Software.\n              \n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n              \t\tSOFTWARE.\n              \t@end-module-license\n              \n              \t@module-configuration:\n              \t\t{\n              \t\t\t\"package\": \"asea\",\n              \t\t\t\"path\": \"asea/asea.js\",\n              \t\t\t\"file\": \"asea.js\",\n              \t\t\t\"module\": \"asea\",\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\n              \t\t\t\"contributors\": [\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\"\n              \t\t\t],\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n              \t\t\t\"repository\": \"https://github.com:volkovasystems/asea.git\",\n              \t\t\t\"test\": \"asea-test.js\",\n              \t\t\t\"global\": true\n              \t\t}\n              \t@end-module-configuration\n              \n              \t@module-documentation:\n              \t\tDetermines if you're on a server environment or a client environment.\n              \n              \t\tReturns unknown if the environment cannot be determined.\n              \t@end-module-documentation\n              \n              \t@include:\n              \t\t{\n              \t\t\t\"harden\": \"harden\"\n              \t\t}\n              \t@end-include\n              */\n\nvar harden = __webpack_require__(80);\n\nharden(\"CLIENT\", \"client\");\nharden(\"SERVER\", \"server\");\nharden(\"UNKNOWN\", \"unknown\");\n\nvar asea = function asea() {\n\tif (asea.client) {\n\t\treturn CLIENT;\n\n\t} else if (asea.server) {\n\t\treturn SERVER;\n\n\t} else {\n\t\treturn UNKNOWN;\n\t}\n};\n\nharden(\"client\",\ntypeof window != \"undefined\" &&\ntypeof document != \"undefined\" &&\ntypeof window.constructor == \"function\" &&\ntypeof document.constructor == \"function\" &&\nwindow.constructor.name == \"Window\" &&\ndocument.constructor.name == \"HTMLDocument\",\nasea);\n\nharden(\"server\",\ntypeof module != \"undefined\" &&\ntypeof global != \"undefined\" &&\n!!module.exports &&\n!!global.process &&\n!!global.process.env,\nasea);\n\nharden(\"unknown\",\nasea.client === false &&\nasea.server === false,\nasea);\n\nmodule.exports = asea;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38)))\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(47), __esModule: true };\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(48), __esModule: true };\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(49), __esModule: true };\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(50), __esModule: true };\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(51), __esModule: true };\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _iterator = __webpack_require__(45);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = __webpack_require__(44);\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(73);\nvar $Object = __webpack_require__(1).Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(74);\nvar $Object = __webpack_require__(1).Object;\nmodule.exports = function getOwnPropertyNames(it){\n  return $Object.getOwnPropertyNames(it);\n};\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(37);\nmodule.exports = __webpack_require__(1).Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(37);\n__webpack_require__(75);\n__webpack_require__(77);\n__webpack_require__(78);\nmodule.exports = __webpack_require__(1).Symbol;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(76);\n__webpack_require__(79);\nmodule.exports = __webpack_require__(26).f('iterator');\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(){ /* empty */ };\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(5)\n  , toLength  = __webpack_require__(70)\n  , toIndex   = __webpack_require__(69);\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(52);\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(12)\n  , gOPS    = __webpack_require__(34)\n  , pIE     = __webpack_require__(19);\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0).document && document.documentElement;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(27);\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(27);\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar create         = __webpack_require__(31)\n  , descriptor     = __webpack_require__(13)\n  , setToStringTag = __webpack_require__(20)\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(6)(IteratorPrototype, __webpack_require__(7)('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getKeys   = __webpack_require__(12)\n  , toIObject = __webpack_require__(5);\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar META     = __webpack_require__(14)('meta')\n  , isObject = __webpack_require__(11)\n  , has      = __webpack_require__(3)\n  , setDesc  = __webpack_require__(4).f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !__webpack_require__(8)(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP       = __webpack_require__(4)\n  , anObject = __webpack_require__(9)\n  , getKeys  = __webpack_require__(12);\n\nmodule.exports = __webpack_require__(2) ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pIE            = __webpack_require__(19)\n  , createDesc     = __webpack_require__(13)\n  , toIObject      = __webpack_require__(5)\n  , toPrimitive    = __webpack_require__(24)\n  , has            = __webpack_require__(3)\n  , IE8_DOM_DEFINE = __webpack_require__(29)\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(2) ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = __webpack_require__(3)\n  , toObject    = __webpack_require__(71)\n  , IE_PROTO    = __webpack_require__(21)('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(10)\n  , core    = __webpack_require__(1)\n  , fails   = __webpack_require__(8);\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(23)\n  , defined   = __webpack_require__(15);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(23)\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(23)\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(15);\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar addToUnscopables = __webpack_require__(53)\n  , step             = __webpack_require__(61)\n  , Iterators        = __webpack_require__(17)\n  , toIObject        = __webpack_require__(5);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(30)(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(10);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__webpack_require__(2), 'Object', {defineProperty: __webpack_require__(4).f});\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.7 Object.getOwnPropertyNames(O)\n__webpack_require__(67)('getOwnPropertyNames', function(){\n  return __webpack_require__(32).f;\n});\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $at  = __webpack_require__(68)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(30)(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(25)('asyncIterator');\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(25)('observable');\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(72);\nvar global        = __webpack_require__(0)\n  , hide          = __webpack_require__(6)\n  , Iterators     = __webpack_require__(17)\n  , TO_STRING_TAG = __webpack_require__(7)('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\n/*;\n              \t@module-license:\n              \t\tThe MIT License (MIT)\n              \t\t@mit-license\n              \n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n              \t\t@email: richeve.bebedor@gmail.com\n              \n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\n              \t\tin the Software without restriction, including without limitation the rights\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n              \t\tcopies of the Software, and to permit persons to whom the Software is\n              \t\tfurnished to do so, subject to the following conditions:\n              \n              \t\tThe above copyright notice and this permission notice shall be included in all\n              \t\tcopies or substantial portions of the Software.\n              \n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n              \t\tSOFTWARE.\n              \t@end-module-license\n              \n              \t@module-configuration:\n              \t\t{\n              \t\t\t\"package\": \"harden\",\n              \t\t\t\"path\": \"harden/harden.js\",\n              \t\t\t\"file\": \"harden.js\",\n              \t\t\t\"module\": \"harden\",\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\n              \t\t\t\"contributors\": [\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\"\n              \t\t\t],\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n              \t\t\t\"repository\": \"https://github.com/volkovasystems/harden.git\",\n              \t\t\t\"test\": \"harden-test.js\",\n              \t\t\t\"global\": true\n              \t\t}\n              \t@end-module-configuration\n              \n              \t@module-documentation:\n              \t\tMakes your property-value non-enumerable, non-configurable and non-writable.\n              \n              \t\tIf entity is given, the property will be bound to the entity.\n              \n              \t\tElse, if this module is used in the browser, the entity defaults to the @code:window;.\n              \n              \t\tElse, if this module is used in a NodeJS environment, the entity defaults to @code:global;.\n              \n              \t\tNote that if the entity is hardened, you cannot use @code:delete; on it.\n              \t@end-module-documentation\n              */var _defineProperty = __webpack_require__(41);var _defineProperty2 = _interopRequireDefault(_defineProperty);var _getOwnPropertySymbols = __webpack_require__(43);var _getOwnPropertySymbols2 = _interopRequireDefault(_getOwnPropertySymbols);var _getOwnPropertyNames = __webpack_require__(42);var _getOwnPropertyNames2 = _interopRequireDefault(_getOwnPropertyNames);var _typeof2 = __webpack_require__(46);var _typeof3 = _interopRequireDefault(_typeof2);function _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\nvar harden = function harden(property, value, entity) {\n\t/*;\n                                                       \t@meta-configuration:\n                                                       \t\t{\n                                                       \t\t\t\"property:required\": [\n                                                       \t\t\t\t\"string\",\n                                                       \t\t\t\t\"symbol\",\n                                                       \t\t\t\t\"number\"\n                                                       \t\t\t],\n                                                       \t\t\t\"value:required\": \"*\",\n                                                       \t\t\t\"entity:optional\": \"object\"\n                                                       \t\t}\n                                                       \t@end-meta-configuration\n                                                       */\n\n\tif (property === \"\" ||\n\ttypeof property != \"string\" &&\n\t(typeof property === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(property)) != \"symbol\" &&\n\ttypeof property != \"number\")\n\t{\n\t\tthrow new Error(\"invalid property\");\n\t}\n\n\tvar self = this;\n\tif (typeof entity != \"undefined\") {\n\t\tself = entity;\n\n\t} else if (typeof global != \"undefined\" && this === global) {\n\t\tself = global;\n\n\t} else if (typeof window != \"undefined\" && this === window) {\n\t\tself = window;\n\t}\n\n\tentity = entity || self;\n\n\tif (typeof entity == \"undefined\" && typeof global != \"undefined\") {\n\t\tentity = global;\n\n\t} else if (typeof entity == \"undefined\" && typeof window != \"undefined\") {\n\t\tentity = window;\n\t}\n\n\t/*;\n   \t@note:\n   \t\tChecking if key exists is intensive because we can define an undefined property\n   \t\t\tand the key will still exists.\n   \t@end-note\n   */\n\tif (typeof entity[property] != \"undefined\" ||\n\t(0, _getOwnPropertyNames2.default)(entity).some(function (key) {return key === property;}) ||\n\t(0, _getOwnPropertySymbols2.default)(entity).some(function (symbol) {return symbol === property;}))\n\t{\n\t\treturn entity;\n\t}\n\n\ttry {\n\t\t(0, _defineProperty2.default)(entity, property, {\n\t\t\t\"enumerable\": false,\n\t\t\t\"configurable\": false,\n\t\t\t\"writable\": false,\n\t\t\t\"value\": value });\n\n\n\t} catch (error) {\n\t\tthrow new Error(\"cannot harden property, \" + property + \", error, \" + error.stack);\n\t}\n\n\tif ((typeof global != \"undefined\" && entity !== global ||\n\ttypeof window != \"undefined\" && entity !== window) &&\n\ttypeof entity.harden == \"undefined\")\n\t{\n\t\ttry {\n\t\t\tObject.defineProperty(entity, \"harden\", {\n\t\t\t\t\"enumerable\": false,\n\t\t\t\t\"configurable\": false,\n\t\t\t\t\"writable\": false,\n\t\t\t\t\"value\": harden.bind(self) });\n\n\n\t\t} catch (error) {\n\t\t\tthrow new Error(\"cannot bind harden, error, \" + error.stack);\n\t\t}\n\t}\n\n\treturn entity;\n};\n\nmodule.exports = harden;\n\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(38)))\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*;\n              \t@module-license:\n              \t\tThe MIT License (MIT)\n              \t\t@mit-license\n              \n              \t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n              \t\t@email: richeve.bebedor@gmail.com\n              \n              \t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n              \t\tof this software and associated documentation files (the \"Software\"), to deal\n              \t\tin the Software without restriction, including without limitation the rights\n              \t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n              \t\tcopies of the Software, and to permit persons to whom the Software is\n              \t\tfurnished to do so, subject to the following conditions:\n              \n              \t\tThe above copyright notice and this permission notice shall be included in all\n              \t\tcopies or substantial portions of the Software.\n              \n              \t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n              \t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n              \t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n              \t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n              \t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n              \t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n              \t\tSOFTWARE.\n              \t@end-module-license\n              \n              \t@module-configuration:\n              \t\t{\n              \t\t\t\"package\": \"madhatter\",\n              \t\t\t\"path\": \"madhatter/madhatter.js\",\n              \t\t\t\"file\": \"madhatter.js\",\n              \t\t\t\"module\": \"madhatter\",\n              \t\t\t\"author\": \"Richeve S. Bebedor\",\n              \t\t\t\"contributors\": [\n              \t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\"\n              \t\t\t],\n              \t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n              \t\t\t\"repository\": \"https://github.com/volkovasystems/madhatter.git\",\n              \t\t\t\"test\": \"madhatter-test.js\",\n              \t\t\t\"global\": true\n              \t\t}\n              \t@end-module-configuration\n              \n              \t@module-documentation:\n              \t\tChecks for syntax error and unused variable.\n              \n              \t\tReturns false if there's no error.\n              \n              \t\tReturns an error or true if erroneous.\n              \t@end-module-documentation\n              \n              \t@include:\n              \t\t{\n              \t\t\t\"asea\": \"asea\",\n              \t\t\t\"esprima\": \"esprima\",\n              \t\t\t\"lire\": \"lire\",\n              \t\t\t\"check\": \"syntax-error\",\n              \t\t\t\"unused\": \"unused\"\n              \t\t}\n              \t@end-include\n              */\n\nvar asea = __webpack_require__(40);\nvar esprima = __webpack_require__(39);\n\n\n\nvar FILE_PATH_PATTERN = /^(\\.*\\~*\\/*[a-zA-Z0-9\\_\\-\\.\\~]+)+(\\.[a-zA-Z0-9\\_\\-]+)+$/;\n\nvar madhatter = function madhatter(script) {\n\t/*;\n                                            \t@meta-configuration:\n                                            \t\t{\n                                            \t\t\t\"script:required\": \"string\"\n                                            \t\t}\n                                            \t@end-meta-configuration\n                                            */\n\n\tif (asea.client) {\n\t\ttry {\n\t\t\tesprima.parse(script);\n\n\t\t} catch (error) {\n\t\t\treturn new Error(\"parse error, \" + error.stack);\n\t\t}\n\n\t\treturn false;\n\n\t} else if (asea.server) {\n\t\tif (FILE_PATH_PATTERN.test(script)) {\n\t\t\ttry {\n\t\t\t\tscript = lire(script, true);\n\n\t\t\t} catch (error) {\n\t\t\t\treturn new Error(\"cannot read script file, \" + error.stack);\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tesprima.parse(script);\n\n\t\t} catch (error) {\n\t\t\treturn new Error(\"parse error, \" + error.stack);\n\t\t}\n\n\t\tvar error = check(script);\n\n\t\tif (error) {\n\t\t\treturn new Error(\"syntax error, \" + error);\n\t\t}\n\n\t\tvar unusedVariable = unused(script).\n\t\tfilter(function onEachUnused(variable) {\n\t\t\treturn !variable.param;\n\t\t}).\n\t\tmap(function onEachUnused(variable) {var\n\t\t\tname = variable.name,loc = variable.loc;\n\n\t\t\treturn name + \":( \" + loc.line + \", \" + loc.column + \" )\";\n\t\t});\n\n\t\tif (unusedVariable.length) {\n\t\t\treturn new Error(\"error unused variable, \" + unusedVariable.join(\", \") + \", \" + script);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//: This is erroneous.\n\treturn true;\n};\n\nmodule.exports = madhatter;\n\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// madhatter.deploy.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 81);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cede5017d901858e1b36","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_global.js\n// module id = 0\n// module chunks = 0","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_core.js\n// module id = 1\n// module chunks = 0","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_descriptors.js\n// module id = 2\n// module chunks = 0","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_has.js\n// module id = 3\n// module chunks = 0","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dp.js\n// module id = 4\n// module chunks = 0","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-iobject.js\n// module id = 5\n// module chunks = 0","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_hide.js\n// module id = 6\n// module chunks = 0","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks.js\n// module id = 7\n// module chunks = 0","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_fails.js\n// module id = 8\n// module chunks = 0","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_an-object.js\n// module id = 9\n// module chunks = 0","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_export.js\n// module id = 10\n// module chunks = 0","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-object.js\n// module id = 11\n// module chunks = 0","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys.js\n// module id = 12\n// module chunks = 0","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_property-desc.js\n// module id = 13\n// module chunks = 0","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_uid.js\n// module id = 14\n// module chunks = 0","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_defined.js\n// module id = 15\n// module chunks = 0","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-bug-keys.js\n// module id = 16\n// module chunks = 0","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iterators.js\n// module id = 17\n// module chunks = 0","module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_library.js\n// module id = 18\n// module chunks = 0","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-pie.js\n// module id = 19\n// module chunks = 0","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_set-to-string-tag.js\n// module id = 20\n// module chunks = 0","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared-key.js\n// module id = 21\n// module chunks = 0","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_shared.js\n// module id = 22\n// module chunks = 0","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-integer.js\n// module id = 23\n// module chunks = 0","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-primitive.js\n// module id = 24\n// module chunks = 0","var global         = require('./_global')\n  , core           = require('./_core')\n  , LIBRARY        = require('./_library')\n  , wksExt         = require('./_wks-ext')\n  , defineProperty = require('./_object-dp').f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks-define.js\n// module id = 25\n// module chunks = 0","exports.f = require('./_wks');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_wks-ext.js\n// module id = 26\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_cof.js\n// module id = 27\n// module chunks = 0","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_dom-create.js\n// module id = 28\n// module chunks = 0","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ie8-dom-define.js\n// module id = 29\n// module chunks = 0","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-define.js\n// module id = 30\n// module chunks = 0","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-create.js\n// module id = 31\n// module chunks = 0","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopn-ext.js\n// module id = 32\n// module chunks = 0","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = require('./_object-keys-internal')\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopn.js\n// module id = 33\n// module chunks = 0","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gops.js\n// module id = 34\n// module chunks = 0","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-keys-internal.js\n// module id = 35\n// module chunks = 0","module.exports = require('./_hide');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_redefine.js\n// module id = 36\n// module chunks = 0","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.symbol.js\n// module id = 37\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 38\n// module chunks = 0","/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        PropertyKind,\n        Messages,\n        Regex,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: {\n            type: 'ArrowParameterPlaceHolder'\n        }\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwUnexpectedToken();\n                }\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwUnexpectedToken();\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwUnexpectedToken();\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 0x2E:  // . dot\n        case 0x28:  // ( open bracket\n        case 0x29:  // ) close bracket\n        case 0x3B:  // ; semicolon\n        case 0x2C:  // , comma\n        case 0x7B:  // { open curly brace\n        case 0x7D:  // } close curly brace\n        case 0x5B:  // [\n        case 0x5D:  // ]\n        case 0x3A:  // :\n        case 0x3F:  // ?\n        case 0x7E:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 0x28) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 0x7B) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (U+003D) marks an assignment or comparison operator.\n            if (code2 === 0x3D) {\n                switch (code) {\n                case 0x2B:  // +\n                case 0x2D:  // -\n                case 0x2F:  // /\n                case 0x3C:  // <\n                case 0x3E:  // >\n                case 0x5E:  // ^\n                case 0x7C:  // |\n                case 0x25:  // %\n                case 0x26:  // &\n                case 0x2A:  // *\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n\n                case 0x21: // !\n                case 0x3D: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 0x3D) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n                }\n            }\n        }\n\n        // 4-character punctuator: >>>=\n\n        ch4 = source.substr(index, 4);\n\n        if (ch4 === '>>>=') {\n            index += 4;\n            return {\n                type: Token.Punctuator,\n                value: ch4,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        ch3 = ch4.substr(0, 3);\n\n        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: ch3,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n        ch2 = ch3.substr(0, 2);\n\n        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 1-character punctuators: < > = ! + - * % & | ^ /\n\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        throwUnexpectedToken();\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                str += unescaped;\n                            } else {\n                                index = restore;\n                                str += ch;\n                            }\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            startLineNumber: startLineNumber,\n            startLineStart: startLineStart,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var tmp = pattern,\n            value;\n\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode code point\n            // escape sequence with a single ASCII symbol to avoid throwing on\n            // regular expressions that are only valid in combination with the\n            // `/u` flag.\n            // Note: replacing with the ASCII symbol `x` might cause false\n            // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n            // perfectly valid pattern that is equivalent to `[a-b]`, but it\n            // would be replaced by `[x-b]` which throws an error.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                    if (parseInt($1, 16) <= 0x10FFFF) {\n                        return 'x';\n                    }\n                    throwError(Messages.InvalidRegExp);\n                })\n                .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            value = new RegExp(tmp);\n        } catch (e) {\n            throwError(Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError(Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError(Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError(Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        skipComment();\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function Position() {\n        this.line = lineNumber;\n        this.column = index - lineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        if (startToken.type === Token.StringLiteral) {\n            this.start = {\n                line: startToken.startLineNumber,\n                column: startToken.start - startToken.startLineStart\n            };\n        } else {\n            this.start = {\n                line: startToken.lineNumber,\n                column: startToken.start - startToken.lineStart\n            };\n        }\n        this.end = null;\n    }\n\n    function Node() {\n        // Skip comment.\n        index = lookahead.start;\n        if (lookahead.type === Token.StringLiteral) {\n            lineNumber = lookahead.startLineNumber;\n            lineStart = lookahead.startLineStart;\n        } else {\n            lineNumber = lookahead.lineNumber;\n            lineStart = lookahead.lineStart;\n        }\n        if (extra.range) {\n            this.range = [index, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            if (last) {\n                while (last && last.range[0] >= this.range[0]) {\n                    lastChild = last;\n                    last = bottomRight.pop();\n                }\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {\n                    this.leadingComments = lastChild.leadingComments;\n                    lastChild.leadingComments = undefined;\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = index;\n            }\n            if (extra.loc) {\n                this.loc.end = new Position();\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.rest = null;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.rest = null;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.rest = null;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body) {\n            this.type = Syntax.Program;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = guardedHandlers;\n            this.handlers = handlers;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    function createError(line, pos, description) {\n        var error = new Error('Line ' + line + ': ' + description);\n        error.index = pos;\n        error.lineNumber = line;\n        error.column = pos - lineStart + 1;\n        error.description = description;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lineNumber, index, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, index, msg);\n        if (extra.errors) {\n            extra.errors.push(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var msg = Messages.UnexpectedToken;\n\n        if (token) {\n            msg = message ? message :\n                (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                Messages.UnexpectedToken;\n\n            if (token.type === Token.Keyword) {\n                if (isFutureReservedWord(token.value)) {\n                    msg = Messages.UnexpectedReserved;\n                } else if (strict && isStrictModeReservedWord(token.value)) {\n                    msg = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        msg = msg.replace('%0', token ? token.value : 'ILLEGAL');\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(lineNumber, index, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            extra.errors.push(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], node = new Node();\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body, node = new Node();\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            tolerateUnexpectedToken(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, param, [], body);\n    }\n\n    function parsePropertyMethodFunction() {\n        var previousStrict, param, method;\n\n        previousStrict = strict;\n        strict = true;\n        param = parseParams();\n        method = parsePropertyFunction(param.params);\n        strict = previousStrict;\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node();\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param, node = new Node();\n\n        token = lookahead;\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !(match(':') || match('('))) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return node.finishProperty('get', key, value, false, false);\n            }\n            if (token.value === 'set' && !(match(':') || match('('))) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    tolerateUnexpectedToken(token);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return node.finishProperty('set', key, value, false, false);\n            }\n            if (match(':')) {\n                lex();\n                value = parseAssignmentExpression();\n                return node.finishProperty('init', id, value, false, false);\n            }\n            if (match('(')) {\n                value = parsePropertyMethodFunction();\n                return node.finishProperty('init', id, value, true, false);\n            }\n\n            value = id;\n            return node.finishProperty('init', id, value, false, true);\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpectedToken(token);\n        } else {\n            key = parseObjectPropertyKey();\n            if (match(':')) {\n                lex();\n                value = parseAssignmentExpression();\n                return node.finishProperty('init', key, value, false, false);\n            }\n            if (match('(')) {\n                value = parsePropertyMethodFunction();\n                return node.finishProperty('init', key, value, true, false);\n            }\n            throwUnexpectedToken(lex());\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        tolerateError(Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        tolerateError(Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        tolerateError(Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        tolerateError(Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            return PlaceHolders.ArrowParameterPlaceHolder;\n        }\n\n        ++state.parenthesisCount;\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                expr = node.finishThisExpression();\n            } else {\n                throwUnexpectedToken(lex());\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = node.finishLiteral(collectRegex());\n            } else {\n                expr = node.finishLiteral(scanRegExp());\n            }\n            peek();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        for (;;) {\n            if (match('.')) {\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        for (;;) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = parseUnaryExpression();\n        if (left === PlaceHolders.ArrowParameterPlaceHolder) {\n            return left;\n        }\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = parseBinaryExpression();\n        if (expr === PlaceHolders.ArrowParameterPlaceHolder) {\n            return expr;\n        }\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n        }\n\n        return expr;\n    }\n\n    // [ES6] 14.2 Arrow Function\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return parseAssignmentExpression();\n    }\n\n    function reinterpretAsCoverFormalsList(expressions) {\n        var i, len, param, params, defaults, defaultCount, options, rest, token;\n\n        params = [];\n        defaults = [];\n        defaultCount = 0;\n        rest = null;\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = expressions.length; i < len; i += 1) {\n            param = expressions[i];\n            if (param.type === Syntax.Identifier) {\n                params.push(param);\n                defaults.push(null);\n                validateParam(options, param, param.name);\n            } else if (param.type === Syntax.AssignmentExpression) {\n                params.push(param.left);\n                defaults.push(param.right);\n                ++defaultCount;\n                validateParam(options, param.left, param.left.name);\n            } else {\n                return null;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            rest: rest,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, body;\n\n        expect('=>');\n        previousStrict = strict;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var oldParenthesisCount, token, expr, right, list, startToken;\n\n        oldParenthesisCount = state.parenthesisCount;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        expr = parseConditionalExpression();\n\n        if (expr === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            if (state.parenthesisCount === oldParenthesisCount ||\n                    state.parenthesisCount === (oldParenthesisCount + 1)) {\n                if (expr.type === Syntax.Identifier) {\n                    list = reinterpretAsCoverFormalsList([ expr ]);\n                } else if (expr.type === Syntax.AssignmentExpression) {\n                    list = reinterpretAsCoverFormalsList([ expr ]);\n                } else if (expr.type === Syntax.SequenceExpression) {\n                    list = reinterpretAsCoverFormalsList(expr.expressions);\n                } else if (expr === PlaceHolders.ArrowParameterPlaceHolder) {\n                    list = reinterpretAsCoverFormalsList([]);\n                }\n                if (list) {\n                    return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n                }\n            }\n        }\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(expr)) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(parseAssignmentExpression());\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                throwUnexpectedToken(token);\n            }\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration(kind) {\n        var init = null, id, node = new Node();\n\n        id = parseVariableIdentifier();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, node = new Node();\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations, kind);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        var node = new Node();\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token, declarations, node = new Node();\n\n        token = lex();\n        declarations = parseVariableDeclarationList();\n\n        return node.finishVariableDeclaration(declarations, token.value);\n    }\n\n    function parseForStatement(node) {\n        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                node.finishForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            // TODO(ikarienator): Should we update the test cases instead?\n            skipComment();\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,\n            node = new Node();\n\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesisCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesisCount;\n\n        return node.finishBlockStatement(sourceElements);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, def;\n\n        token = lookahead;\n        param = parseVariableIdentifier();\n        validateParam(options, token, token.value);\n        if (match('=')) {\n            lex();\n            def = parseAssignmentExpression();\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (index < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, node = new Node();\n\n        expectKeyword('function');\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node();\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionExpression(id, params, defaults, body);\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            /* istanbul ignore if */\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        skipComment();\n        peek();\n        node = new Node();\n        strict = false;\n\n        body = parseSourceElements();\n        return node.finishProgram(body);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            parenthesisCount: 0,\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.0.0';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n   /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./bower_components/esprima/esprima.js\n// module id = 39\n// module chunks = 0","\"use strict\";\n\n/*;\n\t@module-license:\n\t\tThe MIT License (MIT)\n\t\t@mit-license\n\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n\t\t@email: richeve.bebedor@gmail.com\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\t\tof this software and associated documentation files (the \"Software\"), to deal\n\t\tin the Software without restriction, including without limitation the rights\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\tcopies of the Software, and to permit persons to whom the Software is\n\t\tfurnished to do so, subject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all\n\t\tcopies or substantial portions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t\tSOFTWARE.\n\t@end-module-license\n\n\t@module-configuration:\n\t\t{\n\t\t\t\"package\": \"asea\",\n\t\t\t\"path\": \"asea/asea.js\",\n\t\t\t\"file\": \"asea.js\",\n\t\t\t\"module\": \"asea\",\n\t\t\t\"author\": \"Richeve S. Bebedor\",\n\t\t\t\"contributors\": [\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\"\n\t\t\t],\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n\t\t\t\"repository\": \"https://github.com:volkovasystems/asea.git\",\n\t\t\t\"test\": \"asea-test.js\",\n\t\t\t\"global\": true\n\t\t}\n\t@end-module-configuration\n\n\t@module-documentation:\n\t\tDetermines if you're on a server environment or a client environment.\n\n\t\tReturns unknown if the environment cannot be determined.\n\t@end-module-documentation\n\n\t@include:\n\t\t{\n\t\t\t\"harden\": \"harden\"\n\t\t}\n\t@end-include\n*/\n\nconst harden = require( \"harden\" );\n\nharden( \"CLIENT\", \"client\" );\nharden( \"SERVER\", \"server\" );\nharden( \"UNKNOWN\", \"unknown\" );\n\nconst asea = function asea( ){\n\tif( asea.client ){\n\t\treturn CLIENT;\n\n\t}else if( asea.server ){\n\t\treturn SERVER;\n\n\t}else{\n\t\treturn UNKNOWN;\n\t}\n};\n\nharden( \"client\",\n\t( typeof window != \"undefined\" &&\n\ttypeof document != \"undefined\" &&\n\ttypeof window.constructor == \"function\" &&\n\ttypeof document.constructor == \"function\" &&\n\twindow.constructor.name == \"Window\" &&\n\tdocument.constructor.name == \"HTMLDocument\" ),\n\tasea );\n\nharden( \"server\",\n\t( typeof module != \"undefined\" &&\n\ttypeof global != \"undefined\" &&\n\t!!module.exports &&\n\t!!global.process &&\n\t!!global.process.env ),\n\tasea );\n\nharden( \"unknown\",\n\t( asea.client === false &&\n\tasea.server === false ),\n\tasea );\n\nmodule.exports = asea;\n\n\n\n// WEBPACK FOOTER //\n// asea.js","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/define-property.js\n// module id = 41\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/get-own-property-names\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/get-own-property-names.js\n// module id = 42\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/get-own-property-symbols\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/object/get-own-property-symbols.js\n// module id = 43\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/symbol.js\n// module id = 44\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/core-js/symbol/iterator.js\n// module id = 45\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/helpers/typeof.js\n// module id = 46\n// module chunks = 0","require('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc){\n  return $Object.defineProperty(it, key, desc);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/define-property.js\n// module id = 47\n// module chunks = 0","require('../../modules/es6.object.get-own-property-names');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function getOwnPropertyNames(it){\n  return $Object.getOwnPropertyNames(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/get-own-property-names.js\n// module id = 48\n// module chunks = 0","require('../../modules/es6.symbol');\nmodule.exports = require('../../modules/_core').Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/object/get-own-property-symbols.js\n// module id = 49\n// module chunks = 0","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/symbol/index.js\n// module id = 50\n// module chunks = 0","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/fn/symbol/iterator.js\n// module id = 51\n// module chunks = 0","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_a-function.js\n// module id = 52\n// module chunks = 0","module.exports = function(){ /* empty */ };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_add-to-unscopables.js\n// module id = 53\n// module chunks = 0","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_array-includes.js\n// module id = 54\n// module chunks = 0","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_ctx.js\n// module id = 55\n// module chunks = 0","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_enum-keys.js\n// module id = 56\n// module chunks = 0","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_html.js\n// module id = 57\n// module chunks = 0","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iobject.js\n// module id = 58\n// module chunks = 0","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_is-array.js\n// module id = 59\n// module chunks = 0","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-create.js\n// module id = 60\n// module chunks = 0","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_iter-step.js\n// module id = 61\n// module chunks = 0","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_keyof.js\n// module id = 62\n// module chunks = 0","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_meta.js\n// module id = 63\n// module chunks = 0","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-dps.js\n// module id = 64\n// module chunks = 0","var pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gopd.js\n// module id = 65\n// module chunks = 0","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-gpo.js\n// module id = 66\n// module chunks = 0","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_object-sap.js\n// module id = 67\n// module chunks = 0","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_string-at.js\n// module id = 68\n// module chunks = 0","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-index.js\n// module id = 69\n// module chunks = 0","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-length.js\n// module id = 70\n// module chunks = 0","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/_to-object.js\n// module id = 71\n// module chunks = 0","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.array.iterator.js\n// module id = 72\n// module chunks = 0","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.define-property.js\n// module id = 73\n// module chunks = 0","// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./_object-sap')('getOwnPropertyNames', function(){\n  return require('./_object-gopn-ext').f;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.object.get-own-property-names.js\n// module id = 74\n// module chunks = 0","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es6.string.iterator.js\n// module id = 76\n// module chunks = 0","require('./_wks-define')('asyncIterator');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.symbol.async-iterator.js\n// module id = 77\n// module chunks = 0","require('./_wks-define')('observable');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/es7.symbol.observable.js\n// module id = 78\n// module chunks = 0","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/library/modules/web.dom.iterable.js\n// module id = 79\n// module chunks = 0","\"use strict\";\n\n/*;\n\t@module-license:\n\t\tThe MIT License (MIT)\n\t\t@mit-license\n\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n\t\t@email: richeve.bebedor@gmail.com\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\t\tof this software and associated documentation files (the \"Software\"), to deal\n\t\tin the Software without restriction, including without limitation the rights\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\tcopies of the Software, and to permit persons to whom the Software is\n\t\tfurnished to do so, subject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all\n\t\tcopies or substantial portions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t\tSOFTWARE.\n\t@end-module-license\n\n\t@module-configuration:\n\t\t{\n\t\t\t\"package\": \"harden\",\n\t\t\t\"path\": \"harden/harden.js\",\n\t\t\t\"file\": \"harden.js\",\n\t\t\t\"module\": \"harden\",\n\t\t\t\"author\": \"Richeve S. Bebedor\",\n\t\t\t\"contributors\": [\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\"\n\t\t\t],\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n\t\t\t\"repository\": \"https://github.com/volkovasystems/harden.git\",\n\t\t\t\"test\": \"harden-test.js\",\n\t\t\t\"global\": true\n\t\t}\n\t@end-module-configuration\n\n\t@module-documentation:\n\t\tMakes your property-value non-enumerable, non-configurable and non-writable.\n\n\t\tIf entity is given, the property will be bound to the entity.\n\n\t\tElse, if this module is used in the browser, the entity defaults to the @code:window;.\n\n\t\tElse, if this module is used in a NodeJS environment, the entity defaults to @code:global;.\n\n\t\tNote that if the entity is hardened, you cannot use @code:delete; on it.\n\t@end-module-documentation\n*/\n\nconst harden = function harden( property, value, entity ){\n\t/*;\n\t\t@meta-configuration:\n\t\t\t{\n\t\t\t\t\"property:required\": [\n\t\t\t\t\t\"string\",\n\t\t\t\t\t\"symbol\",\n\t\t\t\t\t\"number\"\n\t\t\t\t],\n\t\t\t\t\"value:required\": \"*\",\n\t\t\t\t\"entity:optional\": \"object\"\n\t\t\t}\n\t\t@end-meta-configuration\n\t*/\n\n\tif( property === \"\" ||\n\t\t( typeof property != \"string\" &&\n\t\t\ttypeof property != \"symbol\" &&\n\t\t \ttypeof property != \"number\" ) )\n\t{\n\t\tthrow new Error( \"invalid property\" );\n\t}\n\n\tlet self = this;\n\tif( typeof entity != \"undefined\" ){\n\t\tself = entity;\n\n\t}else if( typeof global != \"undefined\" && this === global ){\n\t\tself = global;\n\n\t}else if( typeof window != \"undefined\" && this === window ){\n\t\tself = window;\n\t}\n\n\tentity = entity || self;\n\n\tif( typeof entity == \"undefined\" && typeof global != \"undefined\" ){\n\t\tentity = global;\n\n\t}else if( typeof entity == \"undefined\" && typeof window != \"undefined\" ){\n\t\tentity = window;\n\t}\n\n\t/*;\n\t\t@note:\n\t\t\tChecking if key exists is intensive because we can define an undefined property\n\t\t\t\tand the key will still exists.\n\t\t@end-note\n\t*/\n\tif( typeof entity[ property ] != \"undefined\" ||\n\t\tObject.getOwnPropertyNames( entity ).some( ( key ) => { return key === property; } ) ||\n\t \tObject.getOwnPropertySymbols( entity ).some( ( symbol ) => { return symbol === property; } ) )\n\t{\n\t\treturn entity;\n\t}\n\n\ttry{\n\t\tObject.defineProperty( entity, property, {\n\t\t\t\"enumerable\": false,\n\t\t\t\"configurable\": false,\n\t\t\t\"writable\": false,\n\t\t\t\"value\": value\n\t\t} );\n\n\t}catch( error ){\n\t\tthrow new Error( `cannot harden property, ${ property }, error, ${ error.stack }` );\n\t}\n\n\tif( ( ( typeof global != \"undefined\" && entity !== global ) ||\n\t\t( typeof window != \"undefined\" && entity !== window ) ) &&\n\t\ttypeof entity.harden == \"undefined\" )\n\t{\n\t\ttry{\n\t\t\tObject.defineProperty( entity, \"harden\", {\n\t\t\t\t\"enumerable\": false,\n\t\t\t\t\"configurable\": false,\n\t\t\t\t\"writable\": false,\n\t\t\t\t\"value\": harden.bind( self )\n\t\t\t} );\n\n\t\t}catch( error ){\n\t\t\tthrow new Error( `cannot bind harden, error, ${ error.stack }` );\n\t\t}\n\t}\n\n\treturn entity;\n};\n\nmodule.exports = harden;\n\n\n\n// WEBPACK FOOTER //\n// harden.js","\"use strict\";\n\n/*;\n\t@module-license:\n\t\tThe MIT License (MIT)\n\t\t@mit-license\n\n\t\tCopyright (@c) 2017 Richeve Siodina Bebedor\n\t\t@email: richeve.bebedor@gmail.com\n\n\t\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\t\tof this software and associated documentation files (the \"Software\"), to deal\n\t\tin the Software without restriction, including without limitation the rights\n\t\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\tcopies of the Software, and to permit persons to whom the Software is\n\t\tfurnished to do so, subject to the following conditions:\n\n\t\tThe above copyright notice and this permission notice shall be included in all\n\t\tcopies or substantial portions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\t\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\t\tSOFTWARE.\n\t@end-module-license\n\n\t@module-configuration:\n\t\t{\n\t\t\t\"package\": \"madhatter\",\n\t\t\t\"path\": \"madhatter/madhatter.js\",\n\t\t\t\"file\": \"madhatter.js\",\n\t\t\t\"module\": \"madhatter\",\n\t\t\t\"author\": \"Richeve S. Bebedor\",\n\t\t\t\"contributors\": [\n\t\t\t\t\"John Lenon Maghanoy <johnlenonmaghanoy@gmail.com>\"\n\t\t\t],\n\t\t\t\"eMail\": \"richeve.bebedor@gmail.com\",\n\t\t\t\"repository\": \"https://github.com/volkovasystems/madhatter.git\",\n\t\t\t\"test\": \"madhatter-test.js\",\n\t\t\t\"global\": true\n\t\t}\n\t@end-module-configuration\n\n\t@module-documentation:\n\t\tChecks for syntax error and unused variable.\n\n\t\tReturns false if there's no error.\n\n\t\tReturns an error or true if erroneous.\n\t@end-module-documentation\n\n\t@include:\n\t\t{\n\t\t\t\"asea\": \"asea\",\n\t\t\t\"esprima\": \"esprima\",\n\t\t\t\"lire\": \"lire\",\n\t\t\t\"check\": \"syntax-error\",\n\t\t\t\"unused\": \"unused\"\n\t\t}\n\t@end-include\n*/\n\nconst asea = require( \"asea\" );\nconst esprima = require( \"esprima\" );\n\n\n\nconst FILE_PATH_PATTERN = /^(\\.*\\~*\\/*[a-zA-Z0-9\\_\\-\\.\\~]+)+(\\.[a-zA-Z0-9\\_\\-]+)+$/;\n\nconst madhatter = function madhatter( script ){\n\t/*;\n\t\t@meta-configuration:\n\t\t\t{\n\t\t\t\t\"script:required\": \"string\"\n\t\t\t}\n\t\t@end-meta-configuration\n\t*/\n\n\tif( asea.client ){\n\t\ttry{\n\t\t\tesprima.parse( script );\n\n\t\t}catch( error ){\n\t\t\treturn new Error( `parse error, ${ error.stack }` );\n\t\t}\n\n\t\treturn false;\n\n\t}else if( asea.server ){\n\t\tif( FILE_PATH_PATTERN.test( script ) ){\n\t\t\ttry{\n\t\t\t\tscript = lire( script, true );\n\n\t\t\t}catch( error ){\n\t\t\t\treturn new Error( `cannot read script file, ${ error.stack }` );\n\t\t\t}\n\t\t}\n\n\t\ttry{\n\t\t\tesprima.parse( script );\n\n\t\t}catch( error ){\n\t\t\treturn new Error( `parse error, ${ error.stack }` );\n\t\t}\n\n\t\tlet error = check( script );\n\n\t\tif( error ){\n\t\t\treturn new Error( `syntax error, ${ error }` );\n\t\t}\n\n\t\tlet unusedVariable = unused( script )\n\t\t\t.filter( function onEachUnused( variable ){\n\t\t\t\treturn !variable.param;\n\t\t\t} )\n\t\t\t.map( function onEachUnused( variable ){\n\t\t\t\tlet { name, loc } = variable;\n\n\t\t\t\treturn `${ name }:( ${ loc.line }, ${ loc.column } )`;\n\t\t\t} );\n\n\t\tif( unusedVariable.length ){\n\t\t\treturn new Error( `error unused variable, ${ unusedVariable.join( \", \" ) }, ${ script }` );\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t//: This is erroneous.\n\treturn true;\n};\n\nmodule.exports = madhatter;\n\n\n\n// WEBPACK FOOTER //\n// madhatter.support.js"],"sourceRoot":""}